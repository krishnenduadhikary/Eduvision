<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functions in C - Eduvision</title>
    <meta name="description"
        content="Learn about functions in C programming: defining, declaring, arguments, return values, call by value vs. call by reference, recursion, storage classes (auto, extern, static, register), scope, and lifetime of variables.">
    <meta name="keywords"
        content="C functions, function declaration, function definition, function call, call by value, call by reference, recursion in C, storage classes, auto, extern, static, register, variable scope, C programming tutorial">
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;900&family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        :root {
            /* Light Mode Defaults */
            --bg-color: #f0f4f8;
            --card-bg: #ffffff;
            --primary-color: #2563eb;
            --secondary-color: #4f46e5;
            --accent-color: #10b981;
            --text-color: #374151;
            --heading-color: #111827;
            --border-color: #d1d5db;
            --gradient-start: var(--primary-color);
            --gradient-end: var(--secondary-color);
            --font-main: 'Poppins', sans-serif;
            --font-logo: 'Nunito', sans-serif;
            --shadow-color: rgba(0, 0, 0, 0.08);
            --card-shadow-color: rgba(0, 0, 0, 0.05);
            --link-color: var(--primary-color);
            --link-hover-color: #1d4ed8;
            --link-hover-bg: #eff6ff;
            --collapsible-content-bg: rgba(0, 0, 0, 0.02);
            --definition-bg: rgba(37, 99, 235, 0.05);
            --table-header-bg: var(--primary-color);
            --table-header-text: white;
            --table-row-even-bg: rgba(0, 0, 0, 0.015);
            --theme-toggle-bg: var(--card-bg);
            --theme-toggle-icon: var(--primary-color);
            --theme-toggle-hover-bg: var(--primary-color);
            --theme-toggle-hover-icon: white;
            --tooltip-bg: #333;
            --tooltip-text: #fff;
            --diagram-bg: var(--collapsible-content-bg);
            --diagram-border: var(--border-color);
        }

        body.dark-mode {
            --bg-color: #0d1117;
            --card-bg: #161b22;
            --text-color: #c9d1d9;
            --heading-color: #f0f6fc;
            --border-color: #30363d;
            --shadow-color: rgba(0, 0, 0, 0.25);
            --card-shadow-color: rgba(0, 0, 0, 0.2);
            --link-color: #58a6ff;
            --link-hover-color: #80baff;
            --link-hover-bg: rgba(88, 166, 255, 0.1);
            --collapsible-content-bg: rgba(255, 255, 255, 0.03);
            --definition-bg: rgba(88, 166, 255, 0.1);
            --table-header-bg: var(--primary-color);
            --table-row-even-bg: rgba(255, 255, 255, 0.03);
            --theme-toggle-bg: var(--card-bg);
            --tooltip-bg: #c9d1d9;
            --tooltip-text: #0d1117;
            --diagram-bg: rgba(255, 255, 255, 0.05);
            --diagram-border: #444c56;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.7;
            overflow-x: hidden;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .eduvision-logo {
            position: absolute;
            top: 18px;
            left: 18px;
            z-index: 1000;
            text-shadow: 0 2px 12px rgba(59, 130, 246, 0.2);
        }

        .eduvision-logo .text-2xl {
            font-size: 1.7rem;
            font-weight: 900;
            display: flex;
            align-items: center;
            gap: 2px;
            letter-spacing: 0.01em;
            font-family: var(--font-logo);
        }

        .eduvision-logo .logo-text {
            color: var(--heading-color);
        }

        body.dark-mode .eduvision-logo .logo-text {
            color: #f0f6fc;
        }

        .eduvision-logo .text-yellow-300 {
            color: #f59e0b !important;
        }

        .eduvision-logo .group:hover .text-yellow-300 {
            color: #fcd34d !important;
        }

        .eduvision-logo a {
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .eduvision-logo svg {
            display: inline-block;
            vertical-align: middle;
            height: 1.5em;
            width: 1.5em;
            margin: 0 2px;
        }

        #theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--theme-toggle-bg);
            color: var(--theme-toggle-icon);
            border: 1px solid var(--border-color);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1rem;
            box-shadow: 0 2px 5px var(--shadow-color);
            z-index: 1001;
            transition: background-color 0.3s, color 0.3s, transform 0.2s, border-color 0.3s;
        }

        #theme-toggle:hover {
            background-color: var(--theme-toggle-hover-bg);
            color: var(--theme-toggle-hover-icon);
            transform: scale(1.1);
        }

        #theme-toggle .icon-sun {
            display: none;
        }

        body.dark-mode #theme-toggle .icon-moon {
            display: none;
        }

        body.dark-mode #theme-toggle .icon-sun {
            display: inline-block;
        }

        .page-header {
            text-align: center;
            margin-top: 80px;
            margin-bottom: 2rem;
            padding: 2rem 1rem;
            border-radius: 12px;
            background: var(--card-bg);
            box-shadow: 0 10px 30px var(--card-shadow-color);
        }

        .page-header h1 {
            font-size: 3rem;
            font-weight: 700;
            color: var(--heading-color);
            background: linear-gradient(90deg, var(--gradient-start), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .page-header p {
            font-size: 1.15rem;
            color: var(--text-color);
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }

        .content-section {
            background-color: var(--card-bg);
            padding: 2.5rem;
            margin-bottom: 2.5rem;
            border-radius: 16px;
            box-shadow: 0 8px 30px var(--card-shadow-color);
            border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s, border-color 0.3s;
        }

        .content-section:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px var(--shadow-color);
        }

        .content-section h2 {
            font-size: 2rem;
            font-weight: 600;
            color: var(--heading-color);
            margin-top: 0;
            margin-bottom: 1.8rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid var(--primary-color);
            display: flex;
            align-items: center;
        }

        .content-section h2 i {
            margin-right: 1rem;
            color: var(--primary-color);
            font-size: 1.8rem;
        }

        .content-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent-color);
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .content-section h4 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .content-section p,
        .content-section ul,
        .content-section .definition {
            margin-bottom: 1.2rem;
            font-size: 1rem;
        }

        .content-section ul {
            padding-left: 25px;
            list-style: none;
        }

        .content-section ul li::before {
            content: "\f138";
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            color: var(--primary-color);
            margin-right: 12px;
            display: inline-block;
            font-size: 0.9em;
        }

        pre[class*="language-"] {
            padding: 1.5em;
            margin: 1.5em 0;
            overflow: auto;
            border-radius: 8px;
            background: #2d2d2d;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode pre[class*="language-"] {
            background: #1e1e1e;
        }

        code[class*="language-"],
        pre[class*="language-"] {
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.95em;
        }

        .collapsible {
            background: linear-gradient(90deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: white;
            cursor: pointer;
            padding: 15px 25px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.2rem;
            font-weight: 600;
            border-radius: 10px;
            margin-bottom: 0.5rem;
            transition: filter 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible:hover {
            filter: brightness(1.15);
        }

        .collapsible.active {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .collapsible-content {
            padding: 0 22px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out, background-color 0.3s;
            background-color: var(--collapsible-content-bg);
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
            margin-bottom: 1.2rem;
            border: 1px solid var(--border-color);
            border-top: none;
        }

        .collapsible-content>div {
            padding: 20px 0;
        }

        .collapsible .icon::before {
            content: '\f078';
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            transition: transform 0.3s ease;
        }

        .collapsible.active .icon::before {
            transform: rotate(-180deg);
        }

        .custom-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px var(--card-shadow-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .custom-table th,
        .custom-table td {
            border: 1px solid var(--border-color);
            padding: 12px 15px;
            text-align: left;
            font-size: 0.95rem;
        }

        .custom-table th {
            background-color: var(--table-header-bg);
            color: var(--table-header-text);
            font-weight: 600;
        }

        .custom-table tr:nth-child(even) {
            background-color: var(--table-row-even-bg);
        }

        .custom-table tr:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .custom-table tr:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted var(--accent-color);
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: max-content;
            max-width: 250px;
            background-color: var(--tooltip-bg);
            color: var(--tooltip-text);
            text-align: center;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            font-size: 0.85em;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .definition {
            background-color: var(--definition-bg);
            border-left: 5px solid var(--primary-color);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
            font-style: normal;
        }

        .definition strong {
            color: var(--primary-color);
        }

        .page-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 3rem;
            margin-bottom: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .nav-button {
            display: inline-flex;
            align-items: center;
            padding: 12px 25px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s, color 0.2s;
            box-shadow: 0 4px 15px var(--shadow-color);
            font-size: 1rem;
        }

        .nav-button i.fa-arrow-left {
            margin-right: 0.5em;
        }

        .nav-button i.fa-arrow-right {
            margin-left: 0.5em;
        }

        .back-button {
            background-color: var(--card-bg);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .back-button:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-color);
        }

        .next-button {
            background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
            color: white;
        }

        .next-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-color);
            filter: brightness(1.1);
        }

        .page-footer {
            text-align: center;
            padding: 2.5rem 0;
            margin-top: 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: #6b7280;
            transition: border-top-color 0.3s;
        }

        body.dark-mode .page-footer {
            color: #9ca3af;
        }

        .diagram-container {
            background-color: var(--diagram-bg);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem auto;
            text-align: center;
            border: 1px solid var(--diagram-border);
            max-width: 600px;
        }

        .diagram-container img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            /* Optional: border around image itself */
        }

        .diagram-container h4 {
            margin-top: 0;
            color: var(--accent-color);
        }

        .syntax-box {
            background-color: var(--collapsible-content-bg);
            padding: 1em;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            margin: 1em 0;
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            /* Handles long lines by wrapping */
            font-size: 0.9em;
            color: var(--text-color);
            /* Ensure text color contrasts with background */
        }

        body.dark-mode .syntax-box {
            background-color: rgba(255, 255, 255, 0.05);
            /* Slightly lighter for dark mode */
        }

        .advantages-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .advantage-card {
            background-color: var(--collapsible-content-bg);
            padding: 1.5rem;
            border-radius: 10px;
            border-left: 4px solid var(--accent-color);
            box-shadow: 0 4px 8px var(--card-shadow-color);
        }

        .advantage-card h4 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 1.15rem;
        }

        @media (max-width: 768px) {
            .page-header h1 {
                font-size: 2.4rem;
            }

            .content-section h2 {
                font-size: 1.7rem;
            }

            .content-section h2 i {
                font-size: 1.5rem;
            }

            #theme-toggle {
                top: 15px;
                right: 15px;
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }

            .eduvision-logo {
                top: 15px;
                left: 15px;
            }

            .eduvision-logo .text-2xl {
                font-size: 1.5rem;
            }

            .page-header {
                margin-top: 70px;
                padding: 1.5rem 0.5rem;
            }

            .content-section {
                padding: 1.5rem;
            }
        }

        @media (max-width: 600px) {
            .page-navigation {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-button {
                width: 100%;
                justify-content: center;
                padding: 15px 20px;
                box-sizing: border-box;
            }
        }
    </style>
</head>

<body>

    <div class="eduvision-logo">
        <div class="text-2xl font-bold">
            <a href="../../../index.html" class="flex items-center group">
                <span class="logo-text">Edu</span>
                <svg xmlns="http://www.w3.org/2000/svg"
                    class="h-6 w-6 mx-0.5 text-yellow-300 group-hover:text-yellow-200 transition-colors duration-300"
                    fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round"
                        d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                <span class="logo-text">ision</span>
            </a>
        </div>
    </div>

    <button id="theme-toggle" title="Toggle dark/light mode">
        <i class="fas fa-moon icon-moon"></i>
        <i class="fas fa-sun icon-sun"></i>
    </button>

    <div class="container">
        <header class="page-header">
            <h1>Functions in C</h1>
            <p>Modularizing code for reusability, readability, and efficiency.</p>
        </header>

        <section class="content-section" id="intro-functions">
            <h2><i class="fas fa-cogs"></i>1. Introduction to Functions</h2>
            <p>Functions are fundamental building blocks in C programming. They allow you to break down a large program
                into smaller, manageable, and reusable pieces of code.</p>
            <div class="diagram-container">
                <img src="https://i.imgur.com/p9s61G2.png" alt="C Program with Functions">
            </div>
            <div class="definition">
                A <strong class="tooltip">function<span class="tooltiptext">Also known as a procedure, subroutine, or
                        module in other languages.</span></strong> is a self-contained block of code or group of
                statements that performs a particular task.
            </div>
            <p>To perform any task, we can create a function. A function can be called many times from different parts
                of the program. This provides <strong class="tooltip">modularity<span class="tooltiptext">Breaking a
                        complex program into smaller, independent modules.</span></strong> and <strong
                    class="tooltip">code reusability<span class="tooltiptext">Writing code once and using it multiple
                        times.</span></strong>.</p>

            <h3>Advantages of Functions:</h3>
            <div class="advantages-grid">
                <div class="advantage-card">
                    <h4>1. Code Reusability</h4>
                    <p>By creating functions in C, you can call them multiple times. So, you don't need to write the
                        same code again and again.</p>
                </div>
                <div class="advantage-card">
                    <h4>2. Code Optimization / Reduced Complexity</h4>
                    <p>Functions make the code more organized and less complex by breaking it down into smaller, logical
                        units. This makes the overall program easier to understand and maintain.</p>
                </div>
                <div class="advantage-card">
                    <h4>3. Easy Debugging</h4>
                    <p>It's easier to find and fix errors (debug) in a modular program because you can isolate problems
                        to specific functions.</p>
                </div>
            </div>
            <p><strong>Example:</strong> Suppose you have to check if 3 numbers (e.g., 781, 883, and 531) are prime or
                not. Without using functions, you would need to write the prime number checking logic 3 times. If you
                use a function, you write the logic once and can reuse it several times.</p>
        </section>

        <section class="content-section" id="types-of-functions">
            <h2><i class="fas fa-stream"></i>2. Types of Functions in C</h2>
            <p>There are two main types of functions in C programming:</p>
            <div class="diagram-container">
                <img src="https://i.imgur.com/cQ0bN2H.png" alt="Types of Functions Diagram">
            </div>
            <ul>
                <li>
                    <strong>1. Library Functions (Standard Functions / Built-in Functions):</strong>
                    <p>These are functions that are already declared and defined in C header files (libraries). You just
                        need to include the appropriate header file to use them. Examples include `printf()`, `scanf()`
                        (from `<stdio.h>`), `sqrt()` (from `<math.h>`), `strlen()` (from `<string.h>`).</p>
                    <ul>
                        <li>System-defined functions are declared in header files.</li>
                        <li>Their implementations (bodies) are often in pre-compiled library files (e.g., `.dll` on
                            Windows, `.so` on Linux, `.lib` or `.a`).</li>
                        <li>To use system-defined functions, the respective header file must be included using
                            `#include`.</li>
                    </ul>
                </li>
                <li>
                    <strong>2. User-Defined Functions:</strong>
                    <p>These are functions created by the programmer to perform specific tasks according to the
                        program's requirements. They help reduce the complexity of a large program and optimize the code
                        by promoting reusability. You can create as many user-defined functions as needed.</p>
                </li>
            </ul>
        </section>

        <section class="content-section" id="user-defined-functions">
            <h2><i class="fas fa-user-cog"></i>3. User-Defined Functions: Elements</h2>
            <p>To write and use an efficient user-defined function, the programmer must be familiar with the following
                three essential elements:</p>
            <ol>
                <li><strong>Function Declaration (Function Prototype)</strong></li>
                <li><strong>Function Call</strong></li>
                <li><strong>Function Definition</strong></li>
            </ol>
            <div class="diagram-container">
                <h4>How a Function Works in C Programming:</h4>
                <img src="https://i.imgur.com/9dY1v6r.png" alt="How a function works in C">
                <p>The execution of a C program begins from the `main()` function. When the compiler encounters a
                    function call (e.g., `functionName();`) inside `main()`, control of the program jumps to the
                    `functionName()` definition. The compiler starts executing the code inside the user-defined
                    function. Once all the code inside the function definition is executed (or a `return` statement is
                    encountered), the control of the program jumps back to the statement immediately following the
                    function call in `main()`.</p>
            </div>


            <button type="button" class="collapsible">A. Function Declaration (Prototype) <span
                    class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>A function declaration (also known as a <strong class="tooltip">function prototype<span
                                class="tooltiptext">A declaration that specifies the function's name, return type, and
                                the types of its parameters.</span></strong>) informs the compiler about the function's
                        existence and its interface. It tells the compiler:</p>
                    <ul>
                        <li>The name of the function.</li>
                        <li>The type of value the function returns (return type).</li>
                        <li>The number and type of arguments (parameters) the function expects to receive.</li>
                    </ul>
                    <p>While declaring, the names of the arguments are optional in the prototype, but their types are
                        mandatory. The function prototype always terminates with a semicolon (`;`).</p>
                    <h4>Syntax:</h4>
                    <div class="syntax-box">
                        return_type function_name(parameter_type1 parameter_name1, parameter_type2 parameter_name2,
                        ...);
                        // or without parameter names:
                        return_type function_name(parameter_type1, parameter_type2, ...);
                        return_type function_name(void); // For functions with no parameters
                    </div>
                    <h4>Examples:</h4>
                    <div class="syntax-box">
                        int add(int a, int b); // Declares a function 'add' that takes two integers and returns an
                        integer.
                        int sum(int, int); // Also valid (parameter names optional in declaration).
                        void greet(void); // Declares a function 'greet' that takes no arguments and returns nothing.
                        float calculateAverage(int count, float total);
                    </div>
                    <p><strong>Note:</strong> At the time of function declaration, the function prototype must be
                        terminated with a semicolon (`;`). It's usually placed at the beginning of the program (before
                        `main()`) or in a header file.</p>
                </div>
            </div>

            <button type="button" class="collapsible">B. Function Call <span class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>A function call is how you execute the code within a function. When a function is called, program
                        control transfers to the function definition.</p>
                    <h4>Syntax:</h4>
                    <div class="syntax-box">
                        function_name(); // Calling a function with no arguments and no return value assigned
                        function_name(argument1, argument2, ...); // Calling a function with arguments
                        variable_to_store_result = function_name(args...); // Calling a function and assigning its
                        return value
                    </div>
                    <h4>Examples:</h4>
                    <div class="syntax-box">
                        add(); // Function without parameters/arguments
                        add(a, b); // Function with parameters/arguments
                        c = sum_values(x, y); // Function with parameters/arguments and a return value assigned to 'c'
                        greet();
                    </div>
                </div>
            </div>

            <button type="button" class="collapsible">C. Function Definition <span class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>The function definition contains the actual block of code (the function body) that performs the
                        specific task of the function. It consists of a function header and a function body.</p>
                    <h4>Syntax:</h4>
                    <div class="syntax-box">
                        return_type function_name(parameter_type1 parameter_name1, parameter_type2 parameter_name2, ...)
                        { // Function Header
                        // Function Body:
                        // Declaration of local variables (if any);
                        // Statements to perform the task;
                        // return statement; // Optional if return_type is void, or if returning a value
                        }
                    </div>
                    <ul>
                        <li><strong>Function Header:</strong> Similar to the declaration but without the semicolon. It
                            includes the return type, function name, and a list of parameters with their types and
                            names.</li>
                        <li><strong>Function Body:</strong> Enclosed in curly braces `{}`, containing declarations and
                            executable statements.</li>
                        <li><strong>`return` statement:</strong> Used to return a value from the function to the caller.
                            If the function's return type is `void`, the `return` statement is optional or can be
                            `return;` without a value.</li>
                    </ul>
                    <h4>Example:</h4>
                    <pre><code class="language-c">
// Function Definition for 'add'
int add(int x, int y) { // Function Header
    // Function Body
    int z;
    z = x + y;
    return z; // Return statement
}

// (or more concisely)
int add_concise(int x, int y) {
    return (x + y);
}

// Function Definition for 'greet'
void greet(void) {
    printf("Hello, World!\n");
    // No return value needed for void function
}
                    </code></pre>
                </div>
            </div>
            <div class="definition">
                <strong>Example: Sum of two numbers (Illustrating Declaration, Call, Definition)</strong>
                <pre><code class="language-c">
#include <stdio.h>
// #include <conio.h> // Not standard, avoid if possible

// 1. Function Declaration (Prototype)
int addNumbers(int a, int b); // or int addNumbers(int, int);

int main() {
    int n1, n2, sum_val;

    printf("Enter two numbers: ");
    scanf("%d %d", &n1, &n2);

    // 2. Function Call
    sum_val = addNumbers(n1, n2);

    printf("Sum = %d\n", sum_val);
    // getch(); // From conio.h, for pausing console in old IDEs
    return 0;
}

// 3. Function Definition
int addNumbers(int a, int b) { // Function Header
    // Function Body
    int result;
    result = a + b;
    return result; // Return statement
}
                </code></pre>
            </div>
        </section>


        <section class="content-section" id="function-arguments">
            <h2><i class="fas fa-exchange-alt"></i>4. Function Arguments and Parameters</h2>
            <p>Parameters provide the mechanism for data communication between the calling function and the called
                function.</p>
            <ul>
                <li><strong>Formal Parameters:</strong> These are the variables declared in the function header of the
                    function definition. They receive values from the calling function. In `int add(int x, int y)`, `x`
                    and `y` are formal parameters.</li>
                <li><strong>Actual Parameters (Arguments):</strong> These are the values or expressions passed to the
                    function when it is called. In `sum = add(num1, num2);`, `num1` and `num2` are actual parameters.
                </li>
            </ul>
            <div class="diagram-container">
                <h4>How to pass arguments to a function:</h4>
                <img src="https://i.imgur.com/j5bV2lU.png" alt="Passing arguments to function">
            </div>
            <h4>Key Points:</h4>
            <ul>
                <li>The number, type, and order of actual parameters in a function call should generally match the
                    formal parameters in the function definition/declaration.</li>
                <li>The value of actual parameters is copied into the formal parameters (this is fundamental to "call by
                    value").</li>
            </ul>
            <h4>Difference between Actual and Formal Parameters:</h4>
            <table class="custom-table">
                <thead>
                    <tr>
                        <th>Actual Parameters</th>
                        <th>Formal Parameters</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Used in the calling function when a function is invoked. (e.g., `c = add(a,b);` where `a,b`
                            are actual)</td>
                        <td>Used in the function header of a called function. (e.g., `int add(int m, int n);` where
                            `m,n` are formal)</td>
                    </tr>
                    <tr>
                        <td>Can be constants, variables, or expressions. (e.g., `add(10,20);`, `add(x,y);`, `add(a+5,
                            b*2);`)</td>
                        <td>Are essentially local variables to the function. They receive values. Expressions or
                            constants are not allowed directly in the formal parameter list declaration itself (e.g.,
                            `int add(int m+n, int 10);` is WRONG).</td>
                    </tr>
                    <tr>
                        <td>Send values to the formal parameters.</td>
                        <td>Receive values from the actual parameters.</td>
                    </tr>
                    <tr>
                        <td>If an address is sent (for call by reference), it's the address of an actual variable.</td>
                        <td>If a formal parameter is intended to receive an address, it should be declared as a pointer.
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="content-section" id="return-statement">
            <h2><i class="fas fa-undo-alt"></i>5. The `return` Statement</h2>
            <p>The `return` statement terminates the execution of the current function and transfers control back to the
                calling function. It can also be used to return a value from the function.</p>
            <h4>Syntax:</h4>
            <div class="syntax-box">
                return; // Used in void functions, or to exit early from a non-void function without returning a
                specific value (though the latter is less common for non-void).
                return expression; // The value of 'expression' is returned to the caller.
            </div>
            <h4>Examples:</h4>
            <div class="syntax-box">
                return a;
                return (a + b);
                return 0; // Common in main() to indicate success
            </div>
            <div class="diagram-container">
                <h4>Return statement of a Function:</h4>
                <img src="https://i.imgur.com/G2p2k4G.png" alt="Return statement visual">
                <p>In the example, the value of the variable `result` (calculated within `addNumbers`) is returned to
                    the `main()` function and stored in the variable `sum`.</p>
            </div>
        </section>

        <section class="content-section" id="inter-function-communication">
            <h2><i class="fas fa-comments"></i>6. Inter-Function Communication & Categories</h2>
            <p>When a function is executed, control transfers from the calling function to the called function and
                eventually back. During this process, information often needs to be exchanged. This is known as
                inter-function communication.</p>
            <div class="diagram-container">
                <img src="https://i.imgur.com/69I4w4T.png" alt="Inter-function Communication Directions">
            </div>
            <p>Functions can be categorized based on how they handle arguments (parameters) and return values, which
                dictates the direction of data flow:</p>
            <ol>
                <li><strong>Downward Communication (Parameters, No Return):</strong> Data flows from the calling
                    function to the called function via parameters, but no data is returned. (e.g., `void printSum(int
                    a, int b);`)</li>
                <li><strong>Upward Communication (No Parameters, Return Value):</strong> No data is passed to the
                    function, but it computes and returns a value to the caller. (e.g., `int getRandomNumber(void);`)
                </li>
                <li><strong>Bi-Directional Communication (Parameters and Return Value):</strong> Data flows to the
                    function via parameters, and the function returns a value back. (e.g., `int add(int a, int b);`)
                </li>
                <li><strong>No Communication (No Parameters, No Return Value):</strong> The function neither accepts
                    parameters nor returns a value. It might perform actions like printing or modifying global
                    variables. (e.g., `void displayMenu(void);`)</li>
            </ol>

            <button type="button" class="collapsible">Categories of Functions by Arguments/Return <span
                    class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <h4>1. Function with No Parameters and No Return Value</h4>
                    <ul>
                        <li>No data transfer between calling and called function through parameters or return values.
                        </li>
                        <li>Control flow transfers.</li>
                        <li>Example: A function that just prints a welcome message.</li>
                    </ul>
                    <pre><code class="language-c">
#include <stdio.h>
// #include <conio.h> // For clrscr, getch - non-standard

void sum_no_param_no_return(); // Declaration

void main_func1() { // Renamed main to avoid conflict
    sum_no_param_no_return(); // Calling function
    // getch();
}

void sum_no_param_no_return() { // Definition
    int a, b, c;
    printf("Enter the values of a and b: ");
    scanf("%d%d", &a, &b);
    c = a + b;
    printf("Sum = %d\n", c);
}
                    </code></pre>

                    <h4>2. Function with No Parameters and Return Value(s)</h4>
                    <ul>
                        <li>No data transfer to the called function via parameters.</li>
                        <li>Data transfer from the called function to the calling function via a return value.</li>
                        <li>Example: A function that reads two numbers and returns their sum.</li>
                    </ul>
                    <pre><code class="language-c">
#include <stdio.h>

int sum_no_param_return_val(); // Declaration

void main_func2() {
    int c_result;
    // clrscr();
    c_result = sum_no_param_return_val(); // Calling function
    printf("Sum = %d\n", c_result);
    // getch();
}

int sum_no_param_return_val() {
    int a, b, c_sum;
    printf("Enter the values of a and b: ");
    scanf("%d%d", &a, &b);
    c_sum = a + b;
    return c_sum; // Returning value
}
                    </code></pre>

                    <h4>3. Function with Parameters and No Return Value</h4>
                    <ul>
                        <li>Data transfer from the calling function to the called function using parameters.</li>
                        <li>No data transfer from the called function back to the calling function via a return value
                            (it's a `void` function).</li>
                        <li>Example: A function that takes two numbers as parameters and prints their sum.</li>
                    </ul>
                    <pre><code class="language-c">
#include <stdio.h>

void sum_param_no_return(int a, int b); // Declaration

void main_func3() {
    int m, n;
    // clrscr();
    printf("Enter m and n values: ");
    scanf("%d%d", &m, &n);
    sum_param_no_return(m, n); // Calling function, passing arguments
    // getch();
}

void sum_param_no_return(int a, int b) { // Definition, receiving parameters
    int c_sum;
    c_sum = a + b;
    printf("Sum = %d\n", c_sum);
}
                    </code></pre>

                    <h4>4. Function with Parameters and Return Value(s)</h4>
                    <ul>
                        <li>Data transfer from the calling function to the called function using parameters.</li>
                        <li>Data transfer from the called function back to the calling function via a return value.</li>
                        <li>This is the most flexible and common type.</li>
                    </ul>
                    <pre><code class="language-c">
#include <stdio.h>

int sum_param_return_val(int a, int b); // Declaration

void main_func4() {
    int m, n, c_result;
    // clrscr();
    printf("Enter m and n values: ");
    scanf("%d%d", &m, &n);
    c_result = sum_param_return_val(m, n); // Calling function
    printf("Sum = %d\n", c_result);
    // getch();
}

int sum_param_return_val(int a, int b) { // Definition
    int c_sum;
    c_sum = a + b;
    return c_sum; // Returning value
}
                    </code></pre>
                </div>
            </div>
        </section>

        <section class="content-section" id="parameter-passing">
            <h2><i class="fas fa-people-arrows"></i>7. Parameter Passing Mechanisms</h2>
            <p>C provides two primary mechanisms to pass parameters (arguments) to a function:</p>
            <div class="diagram-container">
                <img src="https://i.imgur.com/mG4l27q.png" alt="Call by Value vs Call by Reference Flowchart">
            </div>
            <ol>
                <li><strong>Call by Value (Pass by Value)</strong></li>
                <li><strong>Call by Reference (Pass by Reference)</strong> - Achieved using pointers.</li>
            </ol>

            <button type="button" class="collapsible">A. Call by Value <span class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>In call by value, the values of the actual parameters are copied into the formal parameters of
                        the function. Any changes made to the formal parameters within the function do <strong
                            class="highlight">not</strong> affect the original actual parameters in the calling
                        function. This is the default mechanism in C for most data types.</p>
                    <h4>Characteristics:</h4>
                    <ul>
                        <li>A copy of the actual argument's value is passed to the formal argument.</li>
                        <li>Operations are performed on the local copy (formal argument).</li>
                        <li>Changes made to formal arguments are local to the called function and vanish when control
                            returns to the calling function.</li>
                        <li>Original values of actual arguments remain unchanged.</li>
                    </ul>
                    <h4>Example (Swapping two numbers - will not work as intended):</h4>
                    <pre><code class="language-c">
#include <stdio.h>
// #include <conio.h> // For getch - non-standard

// Function prototype (declaration)
void swap_by_value(int x, int y);

int main() {
    int i, j;
    printf("Enter i and j values: ");
    scanf("%d %d", &i, &j);

    printf("Before swapping: i = %d, j = %d\n", i, j);
    swap_by_value(i, j); // Pass values of i and j
    printf("After swapping (in main): i = %d, j = %d\n", i, j); // i and j remain unchanged
    // getch();
    return 0;
}

// Function definition
void swap_by_value(int a, int b) { // a and b are formal parameters, copies of i and j
    int temp;
    printf("  Inside swap_by_value: Before swap: a = %d, b = %d\n", a, b);
    temp = a;
    a = b;
    b = temp;
    printf("  Inside swap_by_value: After swap: a = %d, b = %d\n", a, b);
    // Changes to a and b are local to this function
}
/*
Example Output:
Enter i and j values: 10 20
Before swapping: i = 10, j = 20
  Inside swap_by_value: Before swap: a = 10, b = 20
  Inside swap_by_value: After swap: a = 20, b = 10
After swapping (in main): i = 10, j = 20
*/
                    </code></pre>
                </div>
            </div>

            <button type="button" class="collapsible">B. Call by Reference (using Pointers) <span
                    class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>In call by reference, instead of passing the values, the <strong class="tooltip">addresses<span
                                class="tooltiptext">Memory locations of the variables.</span></strong> of the actual
                        parameters are passed to the function. The formal parameters in the function definition are
                        declared as <strong class="tooltip">pointers<span class="tooltiptext">Variables that store
                                memory addresses.</span></strong>. Any changes made to the data at these addresses (by
                        dereferencing the pointers) directly affect the original actual parameters in the calling
                        function.</p>
                    <h4>Characteristics:</h4>
                    <ul>
                        <li>Addresses of actual arguments are passed to formal pointer arguments.</li>
                        <li>The function operates on the original data indirectly via pointers.</li>
                        <li>Changes made to the data pointed to by formal parameters persist after the function call.
                        </li>
                        <li>Original values of actual arguments can be modified.</li>
                    </ul>
                    <h4>Example (Swapping two numbers - works as intended):</h4>
                    <pre><code class="language-c">
#include <stdio.h>
// #include <conio.h> // For getch - non-standard

// Function prototype (declaration) - parameters are pointers
void swap_by_reference(int *x, int *y);

int main() {
    int i, j;
    printf("Enter i and j values: ");
    scanf("%d %d", &i, &j);

    printf("Before swapping: i = %d, j = %d\n", i, j);
    swap_by_reference(&i, &j); // Pass addresses of i and j
    printf("After swapping (in main): i = %d, j = %d\n", i, j); // i and j are changed
    // getch();
    return 0;
}

// Function definition - parameters are pointers
void swap_by_reference(int *a, int *b) { // a and b are pointers to int
    int temp;
    printf("  Inside swap_by_reference: Before swap: *a = %d, *b = %d\n", *a, *b);
    temp = *a;  // Get the value at address 'a'
    *a = *b;    // Assign value at 'b' to location 'a'
    *b = temp;  // Assign temp to location 'b'
    printf("  Inside swap_by_reference: After swap: *a = %d, *b = %d\n", *a, *b);
}
/*
Example Output:
Enter i and j values: 10 20
Before swapping: i = 10, j = 20
  Inside swap_by_reference: Before swap: *a = 10, *b = 20
  Inside swap_by_reference: After swap: *a = 20, *b = 10
After swapping (in main): i = 20, j = 10
*/
                    </code></pre>
                </div>
            </div>

            <button type="button" class="collapsible">C. Difference: Call by Value vs. Call by Reference <span
                    class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <table class="custom-table">
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>Call by Value</th>
                                <th>Call by Reference (using Pointers)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>What is passed</strong></td>
                                <td>Values of variables are passed.</td>
                                <td>Addresses of variables are passed.</td>
                            </tr>
                            <tr>
                                <td><strong>Effect on Actual Parameters</strong></td>
                                <td>Changes to formal parameters in the function do NOT affect actual parameters in the
                                    calling function.</td>
                                <td>Changes made to the data pointed to by formal parameters DO affect actual parameters
                                    in the calling function.</td>
                            </tr>
                            <tr>
                                <td><strong>Memory Usage</strong></td>
                                <td>Separate memory is allocated for formal parameters (copies).</td>
                                <td>Formal parameters (pointers) store addresses; no new memory for the original data
                                    itself within the called function, just for the pointers.</td>
                            </tr>
                            <tr>
                                <td><strong>Performance</strong></td>
                                <td>Can be slower if large data structures are copied (though C typically passes arrays
                                    by reference-like behavior, and structs can be large).</td>
                                <td>Generally faster if only addresses need to be copied, especially for large data.
                                </td>
                            </tr>
                            <tr>
                                <td><strong>Modification of Originals</strong></td>
                                <td>Original data is safe from unintended modification by the function.</td>
                                <td>Original data can be modified by the function.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <section class="content-section" id="recursion">
            <h2><i class="fas fa-infinity"></i>8. Recursion</h2>
            <p>Recursion is a programming technique where a function calls itself, either directly or indirectly, to
                solve a problem. A recursive function must have:</p>
            <ul>
                <li>A <strong class="tooltip">base case<span class="tooltiptext">A condition that stops the recursion.
                            Without it, the function would call itself infinitely.</span></strong>: A condition under
                    which the function does not call itself, thus terminating the recursive chain.</li>
                <li>A <strong class="tooltip">recursive step<span class="tooltiptext">The part where the function calls
                            itself with a modified argument, moving closer to the base case.</span></strong>: The part
                    of the function that calls itself.</li>
            </ul>
            <h4>Example (Factorial of a number):</h4>
            <pre><code class="language-c">
#include <stdio.h>

// Function to calculate factorial recursively
long int factorial(int n) {
    if (n < 0) {
        printf("Factorial of a negative number doesn't exist.\n");
        return -1; // Indicate error or undefined
    }
    if (n == 0 || n == 1) { // Base case
        return 1;
    } else { // Recursive step
        return n * factorial(n - 1);
    }
}

int main() {
    int num;
    printf("Enter a non-negative integer: ");
    scanf("%d", &num);

    long int fact = factorial(num);

    if (fact != -1) {
        printf("Factorial of %d = %ld\n", num, fact);
    }
    return 0;
}
// Example Input: 5
// Output: Factorial of 5 = 120
            </code></pre>
            <p>Recursion can lead to elegant solutions for problems that have a recursive structure (e.g., tree
                traversals, quicksort, Towers of Hanoi). However, it can also be less efficient than iterative solutions
                due to function call overhead and stack space usage.</p>
        </section>

        <section class="content-section" id="storage-classes">
            <h2><i class="fas fa-hdd"></i>9. Storage Classes</h2>
            <p>Storage classes in C define the <strong class="tooltip">scope<span class="tooltiptext">The region of the
                        program where a variable is accessible.</span></strong>, <strong class="tooltip">lifetime<span
                        class="tooltiptext">The duration for which a variable exists in memory.</span></strong>, and
                <strong class="tooltip">initial value<span class="tooltiptext">The value a variable holds if not
                        explicitly initialized.</span></strong> of variables and functions. They also determine where
                the variable will be stored (e.g., memory or CPU registers).</p>
            <p>There are four storage classes in C programming:</p>
            <ol>
                <li>`auto` (Automatic Storage Class)</li>
                <li>`register` (Register Storage Class)</li>
                <li>`static` (Static Storage Class)</li>
                <li>`extern` (External Storage Class)</li>
            </ol>
            <table class="custom-table">
                <thead>
                    <tr>
                        <th>Storage Class</th>
                        <th>Keyword</th>
                        <th>Storage Place</th>
                        <th>Default Value</th>
                        <th>Scope</th>
                        <th>Lifetime</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Automatic</td>
                        <td>`auto`</td>
                        <td>RAM (Stack)</td>
                        <td>Garbage Value</td>
                        <td>Local (within block/function)</td>
                        <td>Within function/block</td>
                    </tr>
                    <tr>
                        <td>External</td>
                        <td>`extern`</td>
                        <td>RAM (Data Segment)</td>
                        <td>Zero</td>
                        <td>Global (entire program, possibly multiple files)</td>
                        <td>Till the end of the program</td>
                    </tr>
                    <tr>
                        <td>Static</td>
                        <td>`static`</td>
                        <td>RAM (Data Segment)</td>
                        <td>Zero</td>
                        <td>Local (within block/function, but value persists) or File (for global static)</td>
                        <td>Till the end of the program (value retained between calls)</td>
                    </tr>
                    <tr>
                        <td>Register</td>
                        <td>`register`</td>
                        <td>CPU Register (request) or RAM (if unavailable)</td>
                        <td>Garbage Value</td>
                        <td>Local (within block/function)</td>
                        <td>Within function/block</td>
                    </tr>
                </tbody>
            </table>

            <button type="button" class="collapsible">A. `auto` Storage Class <span class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>Variables declared within a function block are automatic (`auto`) by default if no other storage
                        class is specified. The `auto` keyword is rarely used explicitly.</p>
                    <ul>
                        <li><strong>Storage:</strong> Memory (typically the stack).</li>
                        <li><strong>Default Value:</strong> Garbage (unpredictable value).</li>
                        <li><strong>Scope:</strong> Local to the block or function where they are defined.</li>
                        <li><strong>Lifetime:</strong> Exists only while the block or function is being executed. They
                            are created when the block is entered and destroyed when the block is exited.</li>
                    </ul>
                    <h4>Syntax:</h4>
                    <div class="syntax-box">
                        auto data_type variable_name;
                        // Example:
                        auto int detail; // Same as 'int detail;' inside a function
                    </div>
                    <pre><code class="language-c">
#include <stdio.h>

void function1() {
    int x = 10; // auto by default
    printf("Inside function1: x = %d\n", x);
}

void function2() {
    int x = 0;  // auto by default
    printf("Inside function2 (before calling function1): x = %d\n", x);
    function1();
    printf("Inside function2 (after calling function1): x = %d\n", x); // This x is local to function2
}

int main() {
    int x = 100; // auto by default, local to main
    printf("Inside main (before calling function2): x = %d\n", x);
    function2();
    printf("Inside main (after calling function2): x = %d\n", x);
    return 0;
}
/*
Output:
Inside main (before calling function2): x = 100
Inside function2 (before calling function1): x = 0
Inside function1: x = 10
Inside function2 (after calling function1): x = 0
Inside main (after calling function2): x = 100
*/
                    </code></pre>
                </div>
            </div>

            <button type="button" class="collapsible">B. `register` Storage Class <span class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>The `register` storage class is a <span class="tooltip">hint to the compiler<span
                                class="tooltiptext">The compiler is not obligated to store it in a
                                register.</span></span> to store the variable in a CPU register instead of memory for
                        faster access. This is typically used for frequently accessed variables like loop counters.</p>
                    <ul>
                        <li><strong>Storage:</strong> CPU register (if available and compiler agrees), otherwise acts
                            like `auto`.</li>
                        <li><strong>Default Value:</strong> Garbage.</li>
                        <li><strong>Scope:</strong> Local to the block or function.</li>
                        <li><strong>Lifetime:</strong> Within the function/block.</li>
                        <li><strong>Note:</strong> You cannot get the address of a `register` variable using the `&`
                            operator (because registers don't have memory addresses in the same way RAM does). If the
                            compiler cannot store it in a register, it behaves like an `auto` variable, and then you
                            might be able to take its address.</li>
                        <li>Only a few variables can be placed in registers, and the choice is up to the compiler.</li>
                    </ul>
                    <h4>Syntax:</h4>
                    <div class="syntax-box">register data_type variable_name;</div>
                    <pre><code class="language-c">
#include <stdio.h>

void demo() {
    register int i = 20; // Request to store i in a register
    printf("%d\n", i);
    i++; // This i is local to demo and reinitialized on each call if not static
}

int main() {
    demo(); // Output: 20
    demo(); // Output: 20
    demo(); // Output: 20
    // To see persistence, 'i' would need to be static register (if allowed and meaningful)
    // or the register variable should be in a loop within main.
    register int k;
    for(k=0; k<3; k++){
        printf("Loop counter k: %d\n", k);
    }
    return 0;
}
                    </code></pre>
                </div>
            </div>

            <button type="button" class="collapsible">C. `static` Storage Class <span class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>The `static` storage class instructs the compiler to keep a local variable in existence during
                        the lifetime of the program instead of creating and destroying it each time it comes into and
                        goes out of scope. This means its value is retained between function calls.</p>
                    <ul>
                        <li><strong>Storage:</strong> Memory (Data Segment).</li>
                        <li><strong>Default Value:</strong> Zero (0) if not explicitly initialized.</li>
                        <li><strong>Scope:</strong>
                            <ul>
                                <li>For local static variables: Local to the block/function where defined, but the
                                    variable itself persists.</li>
                                <li>For global static variables/functions: Restricted to the file in which they are
                                    declared (file scope).</li>
                            </ul>
                        </li>
                        <li><strong>Lifetime:</strong> Throughout the entire execution of the program.</li>
                        <li>A static variable is initialized only once, when the program starts (or when the function is
                            first called for local static variables, effectively).</li>
                    </ul>
                    <h4>Syntax:</h4>
                    <div class="syntax-box">static data_type variable_name;</div>
                    <h4>Example (Local Static Variable):</h4>
                    <pre><code class="language-c">
#include <stdio.h>

void demo_static() {
    static int i = 20; // Initialized only once
    printf("%d ", i);
    i++;
}

int main() {
    printf("Calling demo_static multiple times:\n");
    demo_static(); // i=20, prints 20, i becomes 21
    demo_static(); // i=21, prints 21, i becomes 22
    demo_static(); // i=22, prints 22, i becomes 23
    printf("\n");
    return 0;
}
// Output:
// Calling demo_static multiple times:
// 20 21 22
                    </code></pre>
                </div>
            </div>

            <button type="button" class="collapsible">D. `extern` Storage Class <span class="icon"></span></button>
            <div class="collapsible-content">
                <div>
                    <p>The `extern` storage class is used to give a reference to a global variable that is defined
                        elsewhere (in the same file or, more commonly, in another file). It tells the compiler that the
                        variable is declared, but its storage is allocated somewhere else. It does not allocate storage
                        for variables.</p>
                    <ul>
                        <li><strong>Storage:</strong> Memory (Data Segment, where the actual global variable is
                            defined).</li>
                        <li><strong>Default Value:</strong> Zero (taken from the global variable's definition).</li>
                        <li><strong>Scope:</strong> Global (can be accessed from any function in the program, across
                            files if defined globally).</li>
                        <li><strong>Lifetime:</strong> Throughout the entire execution of the program.</li>
                    </ul>
                    <h4>Syntax:</h4>
                    <div class="syntax-box">extern data_type variable_name;</div>
                    <h4>Example (Using `extern` in the same file - less common for this specific case):</h4>
                    <pre><code class="language-c">
#include <stdio.h>

int global_x; // Definition of global_x (implicitly extern if accessed from another file)

void modify_global() {
    extern int global_x; // Declaration, refers to the global_x above
    global_x = 100;
}

int main() {
    extern int global_x; // Declaration, refers to the global_x above
    global_x = 10;        // Using the global variable
    printf("Initial global_x = %d\n", global_x);
    modify_global();
    printf("Modified global_x = %d\n", global_x);
    return 0;
}
// Output:
// Initial global_x = 10
// Modified global_x = 100
                    </code></pre>
                    <h4>Example (Using `extern` across files):</h4>
                    <p><strong>file1.c:</strong></p>
                    <pre><code class="language-c">
#include <stdio.h>

int shared_variable = 77; // Definition of the global variable

void display_shared() {
    printf("From file1.c, shared_variable = %d\n", shared_variable);
    shared_variable++;
}
                    </code></pre>
                    <p><strong>file2.c:</strong></p>
                    <pre><code class="language-c">
#include <stdio.h>

// Declaration of display_shared from file1.c
void display_shared(); 

// Declaration that shared_variable is defined elsewhere
extern int shared_variable; 

int main() {
    printf("From file2.c (before call), shared_variable = %d\n", shared_variable);
    display_shared(); // Calls function from file1.c
    printf("From file2.c (after call), shared_variable = %d\n", shared_variable);
    shared_variable = 99;
    display_shared();
    return 0;
}
// To compile (e.g., with GCC): gcc file1.c file2.c -o program
// Output:
// From file2.c (before call), shared_variable = 77
// From file1.c, shared_variable = 77
// From file2.c (after call), shared_variable = 78
// From file1.c, shared_variable = 99
                    </code></pre>
                    <div class="diagram-container">
                        <h4>Global variable from one file used in another:</h4>
                        <img src="https://i.imgur.com/iF2fJ4S.png" alt="Extern keyword usage across files">
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section" id="scope-lifetime">
            <h2><i class="fas fa-history"></i>10. Scope and Lifetime of Variables</h2>
            <p>These concepts are closely related to storage classes.</p>
            <ul>
                <li>
                    <strong>Scope:</strong> Determines the region of the program where a variable can be accessed.
                    <ul>
                        <li><strong>Block/Local Scope:</strong> Accessible only within the block (`{...}`) or function
                            where it's declared. (e.g., `auto`, `register`, local `static` variables).</li>
                        <li><strong>Function Scope:</strong> Only applicable to labels (used with `goto`). A label is
                            visible throughout the function in which it is declared.</li>
                        <li><strong>File Scope (Global Scope):</strong> Accessible from any point in the source file
                            after its declaration. (e.g., global variables, `extern` variables, global `static`
                            variables).</li>
                        <li><strong>Program Scope:</strong> Accessible from any file in the program (achieved with
                            global variables and `extern` declarations).</li>
                    </ul>
                </li>
                <li>
                    <strong>Lifetime:</strong> Determines the period during which a variable exists in memory.
                    <ul>
                        <li><strong>Local Lifetime:</strong> Variable exists only when its defining block/function is
                            active. (e.g., `auto`, `register`).</li>
                        <li><strong>Program Lifetime:</strong> Variable exists for the entire duration of the program's
                            execution. (e.g., global variables, `static` variables, `extern` variables).</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section class="content-section" id="standard-library-functions">
            <h2><i class="fas fa-book-open"></i>11. Standard Library Functions</h2>
            <p>C provides a rich set of standard library functions that are pre-defined and perform common tasks. These
                are declared in header files which must be included using the `#include` preprocessor directive to use
                them.</p>
            <h4>Common Header Files and Their Purpose:</h4>
            <table class="custom-table">
                <thead>
                    <tr>
                        <th>Header File</th>
                        <th>Purpose</th>
                        <th>Example Functions</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>`<stdio.h>`</td>
                        <td>Standard Input/Output operations</td>
                        <td class="operator-col">`printf()`, `scanf()`, `fopen()`, `fclose()`, `getchar()`, `puts()`
                        </td>
                    </tr>
                    <tr>
                        <td>`<stdlib.h>`</td>
                        <td>General utility functions</td>
                        <td class="operator-col">`malloc()`, `calloc()`, `free()`, `exit()`, `rand()`, `atoi()`</td>
                    </tr>
                    <tr>
                        <td>`<string.h>`</td>
                        <td>String manipulation functions</td>
                        <td class="operator-col">`strcpy()`, `strcat()`, `strlen()`, `strcmp()`</td>
                    </tr>
                    <tr>
                        <td>`<math.h>`</td>
                        <td>Mathematical functions</td>
                        <td class="operator-col">`sqrt()`, `pow()`, `sin()`, `cos()`, `log()`</td>
                    </tr>
                    <tr>
                        <td>`<ctype.h>`</td>
                        <td>Character type testing and conversion</td>
                        <td class="operator-col">`isalpha()`, `isdigit()`, `isupper()`, `tolower()`</td>
                    </tr>
                    <tr>
                        <td>`<time.h>`</td>
                        <td>Time and date functions</td>
                        <td class="operator-col">`time()`, `localtime()`, `strftime()`</td>
                    </tr>
                    <tr>
                        <td>`<limits.h>`</td>
                        <td>Defines limits of integral types</td>
                        <td>`INT_MAX`, `CHAR_MIN`</td>
                    </tr>
                    <tr>
                        <td>`<float.h>`</td>
                        <td>Defines limits of floating-point types</td>
                        <td>`FLT_MAX`, `DBL_EPSILON`</td>
                    </tr>
                    <tr>
                        <td>`<assert.h>`</td>
                        <td>Assertion macro for debugging</td>
                        <td class="operator-col">`assert()`</td>
                    </tr>
                    <!-- Add more from your image data if needed -->
                </tbody>
            </table>
            <p>Using these library functions saves development time and often provides optimized implementations.</p>
        </section>


        <div class="page-navigation">
            <a href="topic-3.html" class="nav-button back-button">
                <i class="fas fa-arrow-left"></i> Prev: Control Structures
            </a>
            <a href="../c-programming.html" class="nav-button back-button"
                style="margin-left: auto; margin-right: auto;">
                <i class="fas fa-list"></i> Back to Syllabus
            </a>
            <a href="topic-5.html" class="nav-button next-button">
                Next: Arrays and Strings <i class="fas fa-arrow-right"></i>
            </a>
        </div>

        <footer class="page-footer">
             2024 Eduvision. All rights reserved. Building modular C programs.
        </footer>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/';

        var coll = document.getElementsByClassName("collapsible");
        for (var i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            });
        }

        const themeToggle = document.getElementById('theme-toggle');
        const body = document.body;

        function applyTheme(theme) {
            if (theme === 'dark') {
                body.classList.add('dark-mode');
            } else {
                body.classList.remove('dark-mode');
            }
            localStorage.setItem('theme', theme);
            Prism.highlightAll();
        }

        themeToggle.addEventListener('click', () => {
            if (body.classList.contains('dark-mode')) {
                applyTheme('light');
            } else {
                applyTheme('dark');
            }
        });

        const savedTheme = localStorage.getItem('theme') ||
            (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        applyTheme(savedTheme);
    </script>
</body>

</html>